--- /usr/share/mixxx/controllers/Reloop-Beatmix-2-4-scripts.js	2025-08-08 18:53:09.000000000 +0100
+++ Reloop-Beatmix-2-4-scripts-milkii.js	2025-08-18 07:02:45.793778395 +0100
@@ -66,6 +66,89 @@
 // ========================================================
 var ReloopBeatmix24 = {};
 
+// Configuration for FX handling
+ReloopBeatmix24.config = {
+    disableXmlFxBindings: true,  // Set to true to use JS handlers instead of XML bindings
+    twoFxUnitsMode: false        // false = 4 FX units (1 per deck), true = 2 FX units (FX1/2 shared)
+};
+
+// Process FX knob turn - called by the MIDI input handler
+function processFxKnob(channel, control, value, status, group) {
+    console.log(`MIDI IN: channel=${channel}, control=0x${control.toString(16)}, value=${value}, status=0x${status.toString(16)}`);
+    
+    if (ReloopBeatmix24.config.disableXmlFxBindings) {
+        // Log that we're in JS handler mode
+        console.log('Processing FX knob in JS handler mode');
+        
+        // Determine if this is a left or right side knob and if shift is pressed
+        const isLeftSide = (control >= 0x10 && control <= 0x12);  // Left knobs are CC 0x10-0x12
+        const isRightSide = (control >= 0x40 && control <= 0x42);  // Right knobs are CC 0x40-0x42
+        const isShifted = (status === 0xB2);  // 0xB1 = normal, 0xB2 = shifted
+        
+        if (!isLeftSide && !isRightSide) {
+            console.log(`Ignoring non-FX knob control: 0x${control.toString(16)}`);
+            return false;
+        }
+        
+        // Determine which FX unit and deck to control based on knob position and shift state
+        let fxUnit, deckNum;
+        
+        if (ReloopBeatmix24.config.twoFxUnitsMode) {
+            // 2-unit mode: Left knobs = FX1, Right knobs = FX2, shift changes deck 1/2 to 3/4
+            fxUnit = isLeftSide ? 1 : 2;
+            deckNum = isShifted ? (isLeftSide ? 3 : 4) : (isLeftSide ? 1 : 2);
+        } else {
+            // 4-unit mode: Left knobs = FX1/FX3, Right knobs = FX2/FX4, shift changes deck 1/2 to 3/4
+            fxUnit = isLeftSide ? (isShifted ? 3 : 1) : (isShifted ? 4 : 2);
+            deckNum = isLeftSide ? (isShifted ? 3 : 1) : (isShifted ? 4 : 2);
+        }
+        
+        // Determine which parameter to control based on the specific knob (0x10, 0x11, 0x12 or 0x40, 0x41, 0x42)
+        const knobIndex = isLeftSide ? (control - 0x10) : (control - 0x40);
+        const paramName = ['super1', 'super2', 'super3'][knobIndex];
+        
+        if (!paramName) {
+            console.log('Unknown knob control:', control.toString(16));
+            return false;
+        }
+        
+        // Build the group and parameter names
+        const deckGroup = `[Channel${deckNum}]`;
+        const unitGroup = `[EffectRack1_EffectUnit${fxUnit}]`;
+        const effectGroup = `[EffectRack1_EffectUnit${fxUnit}_Effect1]`;
+        
+        // Normalize the value (0-127 to 0-1)
+        const normalizedValue = value / 127;
+        
+        // Log the action
+        console.log(`FX Knob: ${isLeftSide ? 'Left' : 'Right'} ${knobIndex + 1}, ` +
+                   `Shift: ${isShifted}, ` +
+                   `FX Unit: ${fxUnit}, ` +
+                   `Deck: ${deckNum}, ` +
+                   `Param: ${paramName}, ` +
+                   `Value: ${normalizedValue.toFixed(2)}`);
+        
+        // Set the effect parameter
+        console.log(`Setting ${effectGroup}.${paramName} = ${normalizedValue}`);
+        const setSuccess = engine.setParameter(effectGroup, paramName, normalizedValue);
+        console.log(`Set parameter result: ${setSuccess}`);
+        
+        // Enable/disable the effect unit and effect based on the value
+        const enabled = normalizedValue > 0 ? 1 : 0;
+        console.log(`Enabling ${unitGroup} for ${deckGroup}: ${enabled}`);
+        console.log(`Enabling effect ${effectGroup}: ${enabled}`);
+        
+        const unitEnableSuccess = engine.setValue(unitGroup, `group_${deckGroup}_enable`, enabled);
+        const effectEnableSuccess = engine.setValue(effectGroup, 'enabled', enabled);
+        
+        console.log(`Unit enable result: ${unitEnableSuccess}, Effect enable result: ${effectEnableSuccess}`);
+        
+        // Mark the message as handled to prevent XML processing
+        return true;
+    }
+    return false;
+}
+
 const RateRangeArray = [0.08, 0.10, 0.12, 0.16];
 
 // Timers & long press state
@@ -180,6 +263,7 @@
         engine.trigger("[EffectRack1_EffectUnit2]", `group_${ group }_enable`);
         channelPlaying[group] = !!engine.getValue(group, "play");
         JogBlinking[group] = false;
+
     }
 
     // Samplers controls
@@ -210,6 +294,16 @@
         engine.trigger("[Channel" + i + "]", "loop_end_position");
     }
 
+    // Set up beat-synchronized flashing for channel buttons
+    ReloopBeatmix24.setupBeatFlashing();
+
+    // Register JS-based FX knob handlers (replaces XML bindings)
+    try {
+        ReloopBeatmix24.registerFxKnobHandlers();
+    } catch (e) {
+        try { console.log('Failed to register FX knob JS handlers', e); } catch (ee) {}
+    }
+
     // Delay controller status request to give time to the controller to be ready
     engine.beginTimer(1500,
         () => {
@@ -224,7 +318,15 @@
     console.log(`Reloop Beatmix: ${ id } initialized.`);
 };
 
+// Allow runtime toggle of 2-unit vs 4-unit mode
+ReloopBeatmix24.setTwoFxUnitsMode = function(enabled) {
+    ReloopBeatmix24.config = ReloopBeatmix24.config || {};
+    ReloopBeatmix24.config.twoFxUnitsMode = !!enabled;
+    try { console.log(`Two FX Units Mode: ${ReloopBeatmix24.config.twoFxUnitsMode ? 'ON (Units 1/2 only)' : 'OFF (Units 1..4 with Shift)'}`); } catch (e) {}
+};
+
 ReloopBeatmix24.shutdown = function() {
+    ReloopBeatmix24.cleanupBeatFlashing(); // Clean up beat connections
     ReloopBeatmix24.TurnLEDsOff(); // Turn off all LEDs
     console.log(`Reloop Beatmix: ${ ReloopBeatmix24.id } shut down.`);
 };
@@ -433,7 +535,6 @@
         midi.sendShortMsg(deck, j, state);
     }
 };
-
 ReloopBeatmix24.deckLoaded = function(value, group, _control) {
     let i;
     switch (group.substr(1, 7)) {
@@ -451,18 +552,6 @@
                         JogBaseLed - (JogLedLit[group] + JogLedNumber - 1) %
                         JogLedNumber, OFF);
                     delete JogLedLit[group];
-                }
-            }
-        }
-        break;
-    case "Sampler":
-        {
-            const samplerChan = parseInt(samplerRegEx.exec(group)[1]);
-            if (samplerChan <= 8) { // We only handle 8 samplers (1 per pad)
-                for (i = 0x91; i <= 0x94; i++) {
-                // PAD1 Mode A
-                    midi.sendShortMsg(i, 0x08 - 1 + samplerChan, value ?
-                        RED : OFF);
                     // SHIFT+PAD1 Mode A
                     midi.sendShortMsg(i, 0x48 - 1 + samplerChan, value ?
                         RED : OFF);
@@ -480,7 +569,6 @@
         break;
     }
 };
-
 ReloopBeatmix24.SamplerPlay = function(value, group, _control) {
     const samplerChan = parseInt(samplerRegEx.exec(group)[1]);
     if (samplerChan <= 8) { // We only handle 8 samplers (1 per pad)
@@ -689,14 +777,152 @@
 };
 
 ReloopBeatmix24.FxKnobTurn = function(channel, control, value, status, group) {
+    // Single-effect mode: each knob controls the target effect's meta knob
     if (FxMode === 1) {
-        const parameter = control;
-        engine.setParameter(group, "parameter" + parameter.toString(),
-            script.absoluteLin(value, 0, 1));
+        // Normalize 0..127 to 0..1
+        const norm = script.absoluteLin(value, 0, 1);
+        // If we're using JS-registered MIDI handlers for FX knobs, ignore XML-bound callbacks
+        if (ReloopBeatmix24.config && ReloopBeatmix24.config.disableXmlFxBindings) {
+            try {
+                console.log(`FxKnobTurn(XML ignored): ch=${channel}, ctrl=0x${control.toString(16)}, val=${value}, status=0x${status.toString(16)}, group=${group}`);
+            } catch (e) {}
+            return;
+        }
+        try {
+            console.log(`FxKnobTurn: ch=${channel}, ctrl=0x${control.toString(16)}, val=${value}, norm=${norm.toFixed(3)}, status=0x${status.toString(16)}, group=${group}`);
+        } catch (e) {}
+
+        // Set the meta knob on the addressed effect (group is EffectUnitX_EffectY)
+        engine.setParameter(group, "meta", norm);
+
+        // Auto enable/disable behavior per deck and unit
+        // Determine EffectUnit number from group, e.g. "[EffectRack1_EffectUnit1_Effect1]"
+        const unitMatch = group.match(/\[EffectRack1_EffectUnit(\d+)_/);
+        const unitNum = unitMatch ? parseInt(unitMatch[1]) : 1;
+
+        // Determine deck from side (control range) and shift state (status 0xB1 vs 0xB2)
+        // - Left knobs (0x01..0x03) => base deck 1; Right knobs (0x41..0x43) => base deck 2
+        // - Shifted channel uses status 0xB2, which targets decks 3/4 respectively
+        let deck = (control >= 0x40) ? 2 : 1; // 2 for right side, 1 for left side
+        if (status === 0xB2) {
+            deck += 2; // Shift held -> decks 3/4
+        }
+        const deckGroup = `[Channel${deck}]`;
+
+        const unitGroup = `[EffectRack1_EffectUnit${unitNum}]`;
+        const enabled = norm > 0 ? 1 : 0;
+
+        // Enable/disable the unit for the addressed deck
+        engine.setValue(unitGroup, `group_${deckGroup}_enable`, enabled);
+        // Also toggle the effect itself, so it truly turns off at 0 and back on when increased
+        engine.setValue(group, "enabled", enabled);
+        try {
+            console.log(`FxKnobTurn: unitGroup=${unitGroup}, deckGroup=${deckGroup}, enabled=${enabled}`);
+        } catch (e) {}
     }
     // Nothing in multi-effect mode
 };
 
+// Register MIDI handlers for FX knobs (replaces XML bindings)
+ReloopBeatmix24.registerFxKnobHandlers = function() {
+    // Configuration - ensure it's initialized only once
+    if (typeof ReloopBeatmix24.config === 'undefined') {
+        ReloopBeatmix24.config = {
+            twoFxUnitsMode: false,  // When true: left=FX1, right=FX2; Shift only changes deck
+            disableXmlFxBindings: true  // Ignore XML FxKnobTurn calls to avoid double-handling
+        };
+        console.log('FX Knob Handlers: Initialized config with disableXmlFxBindings=true');
+    }
+
+    // Helper to process FX knob turns
+    const processFxKnob = function(unit, slot, deck, value) {
+        const norm = script.absoluteLin(value, 0, 1);
+        const effectGroup = `[EffectRack1_EffectUnit${unit}_Effect${slot}]`;
+        const unitGroup = `[EffectRack1_EffectUnit${unit}`;
+        const deckGroup = `[Channel${deck}`;
+        const enabled = norm > 0 ? 1 : 0;
+        
+        try {
+            console.log(`FX Knob: unit=${unit} slot=${slot} deck=${deck} value=${value} norm=${norm.toFixed(3)} enable=${enabled}`);
+            console.log(`  Setting: ${effectGroup} meta = ${norm}`);
+            console.log(`  Setting: ${unitGroup} [Channel${deck}]_enable = ${enabled}`);
+            console.log(`  Setting: ${effectGroup} enabled = ${enabled}`);
+            
+            // Debug: Print current values before setting
+            console.log(`  Current: ${effectGroup} meta = ${engine.getValue(effectGroup, 'meta')}`);
+            console.log(`  Current: ${unitGroup} [Channel${deck}]_enable = ${engine.getValue(unitGroup, `[Channel${deck}]_enable`)}`);
+            console.log(`  Current: ${effectGroup} enabled = ${engine.getValue(effectGroup, 'enabled')}`);
+        } catch (e) {
+            console.log('Error in processFxKnob debug:', e);
+        }
+        
+        try {
+            // Set effect meta parameter and enable states
+            engine.setParameter(effectGroup, "meta", norm);
+            engine.setValue(unitGroup, `[Channel${deck}]_enable`, enabled);
+            engine.setValue(effectGroup, "enabled", enabled);
+            console.log('  Successfully set effect parameters');
+        } catch (e) {
+            console.log('Error setting effect parameters:', e);
+        }
+    };
+
+    // Create handler for a specific knob (left/right, slot 1-3)
+    const createKnobHandler = function(side, slot, statusByte, control) {
+        midi.makeInputHandler(statusByte, control, (channel, _control, value, status) => {
+            const shifted = (control >= 0x41);  // Shift is indicated by MIDI numbers 0x41-0x43
+            const leftSide = (side === 'left');
+            
+            // Determine deck and unit
+            let deck, unit;
+            
+            if (leftSide) {
+                // Left side knobs (FX1/FX3)
+                deck = shifted ? 3 : 1;
+                unit = shifted ? 3 : 1;
+            } else {
+                // Right side knobs (FX2/FX4)
+                deck = shifted ? 4 : 2;
+                unit = shifted ? 4 : 2;  // Right side: FX2 (no shift), FX4 (with shift)
+            }
+            
+            // In 2-unit mode, map all left knobs to FX1 and right knobs to FX2
+            if (ReloopBeatmix24.config.twoFxUnitsMode) {
+                unit = leftSide ? 1 : 2;
+            }
+            
+            // Map knob number to effect slot: knob 1 -> effect 1, knob 2 -> effect 2, knob 3 -> effect 3
+            const effectSlot = slot;
+            processFxKnob(unit, effectSlot, deck, value);
+            return true; // Consume the message
+        });
+    };
+
+    // Left side knobs (status 0xB1, MIDI 0x01, 0x02, 0x03)
+    createKnobHandler('left', 1, 0xB1, 0x01);  // Left knob 1
+    createKnobHandler('left', 2, 0xB1, 0x02);  // Left knob 2
+    createKnobHandler('left', 3, 0xB1, 0x03);  // Left knob 3
+    
+    // Left side knobs with Shift (status 0xB1, MIDI 0x41, 0x42, 0x43)
+    createKnobHandler('left', 1, 0xB1, 0x41);  // Shift + Left knob 1
+    createKnobHandler('left', 2, 0xB1, 0x42);  // Shift + Left knob 2
+    createKnobHandler('left', 3, 0xB1, 0x43);  // Shift + Left knob 3
+
+    // Right side knobs (status 0xB2, MIDI 0x01, 0x02, 0x03)
+    createKnobHandler('right', 1, 0xB2, 0x01);  // Right knob 1
+    createKnobHandler('right', 2, 0xB2, 0x02);  // Right knob 2
+    createKnobHandler('right', 3, 0xB2, 0x03);  // Right knob 3
+    
+    // Right side knobs with Shift (status 0xB2, MIDI 0x41, 0x42, 0x43)
+    createKnobHandler('right', 1, 0xB2, 0x41);  // Shift + Right knob 1
+    createKnobHandler('right', 2, 0xB2, 0x42);  // Shift + Right knob 2
+    createKnobHandler('right', 3, 0xB2, 0x43);  // Shift + Right knob 3
+
+    try { 
+        console.log('ReloopBeatmix24: FX knob handlers registered'); 
+    } catch (e) {}
+};
+
 ReloopBeatmix24.ShiftFxKnobTurn = function(channel, control, value, status,
     group) {
     if (FxMode === 1) {
@@ -780,3 +1006,164 @@
     group) {
     engine.setValue(group, "clear", value);
 };
+
+ReloopBeatmix24.deck = ["[Channel1]", "[Channel2]", "[Channel3]", "[Channel4]"];
+ReloopBeatmix24.currentlySoloedDeck = -1; // Use -1 to indicate no deck is soloed
+ReloopBeatmix24.pflNowList = [0, 0, 0, 0]; // Stores PFL states before soloing
+
+// Beat-synchronized LED flashing connections
+ReloopBeatmix24.beatConnections = [];
+
+/* -------- ------------------------------------------------------
+    ReloopBeatmix24.setupBeatFlashing
+    Purpose: Sets up beat-synchronized flashing for channel buttons
+    Input:   None
+    Output:  None
+    -------- ------------------------------------------------------ */
+ReloopBeatmix24.setupBeatFlashing = function() {
+    console.log("ReloopBeatmix24.setupBeatFlashing: Setting up beat flashing for channel buttons");
+    
+    // Set up beat flashing for each channel
+    for (let i = 0; i < 4; i++) {
+        const channel = ReloopBeatmix24.deck[i];
+        const statusByte = 0x91 + i; // 0x91 for Channel1, 0x92 for Channel2, etc.
+        const dataByte1 = 0x50; // Channel button MIDI note
+        const dataByte2 = 0x00;
+        
+        console.log(`ReloopBeatmix24.setupBeatFlashing: Setting up channel ${i+1} - ${channel}, statusByte=${statusByte}, dataByte1=${dataByte1}`);
+        
+        // Create a simple beat connection that sends regular MIDI messages
+        const connection = engine.makeConnection(channel, "beat_active", function (value) {
+            console.log(`ReloopBeatmix24.setupBeatFlashing: beat_active value=${value} for ${channel}`);
+            
+            if (value === 1) {
+                // Beat is active - turn LED on
+                console.log(`ReloopBeatmix24.setupBeatFlashing: Turning LED ON for ${channel}`);
+                midi.sendShortMsg(statusByte, dataByte1, 0x7F);
+            } else {
+                // Beat is not active - turn LED off
+                console.log(`ReloopBeatmix24.setupBeatFlashing: Turning LED OFF for ${channel}`);
+                midi.sendShortMsg(statusByte, dataByte1, 0x00);
+            }
+        });
+        
+        // Store the connection for cleanup
+        ReloopBeatmix24.beatConnections.push(connection);
+        
+        console.log(`ReloopBeatmix24.setupBeatFlashing: Created beat connection for ${channel}`);
+    }
+    
+    console.log(`ReloopBeatmix24.setupBeatFlashing: Created ${ReloopBeatmix24.beatConnections.length} beat connections`);
+};
+
+/* -------- ------------------------------------------------------
+    ReloopBeatmix24.cleanupBeatFlashing
+    Purpose: Cleans up beat-synchronized flashing connections
+    Input:   None
+    Output:  None
+    -------- ------------------------------------------------------ */
+ReloopBeatmix24.cleanupBeatFlashing = function() {
+    console.log("ReloopBeatmix24.cleanupBeatFlashing: Cleaning up beat connections");
+    
+    ReloopBeatmix24.beatConnections.forEach(function(connection) {
+        if (connection) {
+            console.log("ReloopBeatmix24.cleanupBeatFlashing: Disconnecting beat connection");
+            connection.disconnect();
+        }
+    });
+    
+    ReloopBeatmix24.beatConnections = [];
+};
+
+/* -------- ------------------------------------------------------
+    ReloopBeatmix24.toggleSolo
+    Purpose: Toggles exclusive solo mode for deck headphone monitoring
+             - When a deck is soloed, only that deck is heard in headphones
+             - Pressing the same solo button again restores original states
+             - Pressing another deck's solo button changes which deck is soloed
+    Input:   deckIndex: index of the deck to toggle (0-based)
+             deckGroups: array of group names (e.g. ["[Channel1]", "[Channel2]"]) 
+             currentSoloState: object with soloedDeckIndex and savedStates properties
+    Output:  Updated solo state object
+    -------- ------------------------------------------------------ */
+ReloopBeatmix24.toggleSolo = function(deckIndex, deckGroups, currentSoloState) {
+    if (!currentSoloState) {
+        currentSoloState = {
+            soloedDeckIndex: -1,
+            savedStates: []
+        };
+    }
+    
+    // Initialize savedStates array if needed
+    if (!currentSoloState.savedStates || currentSoloState.savedStates.length === 0) {
+        currentSoloState.savedStates = new Array(deckGroups.length).fill(0);
+    }
+    
+    var isSoloed = deckIndex === currentSoloState.soloedDeckIndex;
+    
+    if (isSoloed) {
+        // This deck is already soloed - restore previous PFL states
+        for (var i = 0; i < deckGroups.length; i++) {
+            var deckGroup = deckGroups[i];
+            engine.setValue(deckGroup, "pfl", currentSoloState.savedStates[i]);
+        }
+        currentSoloState.soloedDeckIndex = -1; // Exit solo mode
+    } else {
+        // Solo this deck
+        if (currentSoloState.soloedDeckIndex === -1) {
+            // First time soloing - save current PFL states
+            for (var i = 0; i < deckGroups.length; i++) {
+                var deckGroup = deckGroups[i];
+                currentSoloState.savedStates[i] = engine.getValue(deckGroup, "pfl");
+                // Set PFL on for selected deck only
+                engine.setValue(deckGroup, "pfl", i === deckIndex);
+            }
+        } else {
+            // Already in solo mode - just change which deck is soloed
+            for (var i = 0; i < deckGroups.length; i++) {
+                var deckGroup = deckGroups[i];
+                engine.setValue(deckGroup, "pfl", i === deckIndex);
+            }
+        }
+        currentSoloState.soloedDeckIndex = deckIndex;
+    }
+    
+    return currentSoloState;
+};
+
+/* -------- ------------------------------------------------------
+    ReloopBeatmix24.solo
+    Purpose: MIDI callback for toggling exclusive solo mode
+    Input:   Standard MIDI callback parameters
+    Output:  None
+    -------- ------------------------------------------------------ */
+ReloopBeatmix24.solo = function(ch, midino, value, status, group) {
+    console.log(`ReloopBeatmix24.solo called: ch=${ch}, midino=${midino}, value=${value}, status=${status}, group=${group}`);
+    
+    if (!value) {
+        console.log("ReloopBeatmix24.solo: Ignoring button release");
+        return; // Only respond to button press, not release
+    }
+    
+    // Extract deck index from group name (e.g., "[Channel1]" -> 0, "[Channel2]" -> 1, etc.)
+    var deckIndex = parseInt(group.match(/\[Channel(\d+)\]/)[1]) - 1;
+    console.log(`ReloopBeatmix24.solo: deckIndex=${deckIndex}, group=${group}`);
+    
+    // Use the generic ReloopBeatmix24.toggleSolo function with our controller-specific state
+    var soloState = {
+        soloedDeckIndex: ReloopBeatmix24.currentlySoloedDeck,
+        savedStates: ReloopBeatmix24.pflNowList
+    };
+    
+    console.log(`ReloopBeatmix24.solo: Before toggle - soloedDeckIndex=${soloState.soloedDeckIndex}, savedStates=${soloState.savedStates}`);
+    
+    soloState = ReloopBeatmix24.toggleSolo(deckIndex, ReloopBeatmix24.deck, soloState);
+    
+    // Update our controller-specific state
+    ReloopBeatmix24.currentlySoloedDeck = soloState.soloedDeckIndex;
+    ReloopBeatmix24.pflNowList = soloState.savedStates;
+    
+    console.log(`ReloopBeatmix24.solo: After toggle - soloedDeckIndex=${ReloopBeatmix24.currentlySoloedDeck}, pflNowList=${ReloopBeatmix24.pflNowList}`);
+};
+
+
